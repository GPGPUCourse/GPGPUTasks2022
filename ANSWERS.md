1. В `y2` в отличие от `y` присутствует зависимость между последовательными 
элементами массива. Эту рекуррентную связь, кажется нельзя никак свести к 
независимому подсчёту элементов `y2` "по формуле". Поэтому я считаю, что 
проще реализовать первый.
2. Первое измерение, `x` совпадает по размеру с warp'ом.
То есть `x` меняется внутри warp'а, в то время как `y` внутри
warp'а постоянное.
`x` ~ get_local_id(0),
`y` ~ get_local_id(1),
get_local_size(1) = 32.
Запишем `idx` в терминологии x'ов и y'ов.
`idx` ~ y + 32 * x.
Рассмотрим, как сработает выделение остатка от деления на 32:
`idx % 32` = y % 32.
Что означает, что внутри одного warp'а будет выбираться одна и та же ветка 
в if'е. Code divergence не произойдёт.
3. `x` ~ get_local_id(0),
   `y` ~ get_local_id(1),
   get_local_size(1) = 32.
   
   a. `data[get_local_id(0) + get_local_size(0) * get_local_id(1)]` ~
   data[x+32*y].
   Внутри одного warp'а используются подряд расположенные данные.
   Один warp читает в одну кеш-линию.
   Таким образом, внутри workgroup используется 32 кеш-линии.
   Обращение к памяти coalesced.

   b. `data[get_local_id(1) + get_local_size(1) * get_local_id(0)]` ~
   data[y+32*x].
   Из-за того, что данные не расположены подряд внутри одного warp'а,
   warp использует 32 кеш-линии. workgroup использует 32 * 32 = 1024
   кеш-линий. Обращение к памяти не coalesced.

   c. `data[get_local_id(0) + get_local_size(0) * get_local_id(1)]` ~
   data[1+x+32*y].
   Всё почти как в пункте "a", только внутри warp'а последнее число не
   помещается в одну кеш-линии (32 * 4 = 128). В workgroup 32*2 = 64
   кеш-линий. В целом, это не так плохо, как в пункте "b". 
