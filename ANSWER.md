# Ответы
## Задача 1
Проще будет реализовать сигнал `y1`, т.к. для его реализации нужно всего лишь 3 элемента стоящих рядом в `x` и 
практический не будет препятствий распараллелить вычисление просто написав формулу, что не скажешь о сигнале `y2`, его вычисление
требует знаний либо о предыдущих значениях `y2`, либо о префиксе `x` в целом, и если начать реализовывать через предыдущие значения `y2`,
то получится просто линейный алгоритм, если начать развертывать формулу и считать отдельно для каждого элемента все заново, то будет неэффективно, 
т.е. придется придумывать что-то более сложное.

## Задача 2
Code divergence не будет, т.к. `get_local_size(1) == 32`, а значит `idx % 32 == get_local_id(1) % 32`, 
о warp'ы разделятся так, что у всех item'ов `get_local_id(1)` будет одинаковым.

## Задача 3

### a
Обращение к памяти будет coalesced, т.к. соседние workitem'ы будут обращаться к соседним элементам (по таким же соображениям из задачи 2).
`128 байт = 32 элемента * 4 байта (размер float)`. 
В одной рабочей группе соседние warp'ы будут обращаться к соседним кускам памяти по 32 элемента, значит каждый warp будет работать со своей кеш линией (причем 1, т.к. coalesced).
Значит кеш линий записей будет 32, т.к. 32 warp'а в одной рабочей группе.

### b
Обращение к памяти не будет coalesced, т.к. расстояние запрашиваемых элементов будет больше чем размер кеш линии. 
Значит кеш линии записей будет `32 * 32 = 1024`.

### c
Обращение к памяти будет coalesced (но не совсем), т.к. запрашиваемые элементы будут лежать подряд, 
но при этом кеш линий записей в одном warp будет 2, т.к. последний item выйдет на другую кеш линию.
Т.е. записей кеш линий в рабочей группе будет `32 * 2 = 64`.

