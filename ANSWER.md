# Задание 2. Теоретическое задание

**1)** Пробще и быстрее будет реализовать первый сигнал, так как вычисление `y2[n]` завязано на вычисление `y2[n-1]` и `y2[n-2]`, т.е на вычислении предудущих.

**2)** Так как номер WorkItem по оси x меняется чаще всего, затем по оси y и затем по оси z и размеры workgroup (32, 32, 1), значит workgroup можно представить как матрицу, из которой поочередно берутся строки.

`get_local_id(1)` = y, где 0 <= y <= 31. 
Заметим, что y для каждого warp-a будет одинаковым из-за соображений выше.

`get_local_size(1)` = 32.

`get_local_id(0)` = x, где 0 <= x <= 31.

Соберем все вместе:

`(y + 32 * x) % 32 < 16` равносильно `y < 16`. А y для каждого warp-а константа, значит code divergence не будет.

**3)** 

Все те же размышления из второго номера.

(a) 

`get_local_id(0)` = x, где 0 <= x <= 31.

`get_local_size(0)` = 32.

`get_local_id(1)` = y, где 0 <= y <= 31. 
Заметим, что y для каждого warp-a будет одинаковым из-за соображений выше.

`get_local_id(0) + get_local_size(0) * get_local_id(1) = x + 32 * y`, обращение к памяти будет coalesced, так как внутри одного warp-а мы будем обращаться к одной линии кэша. 32 кэш линий записей произойдет в одной рабочей группе.

(b) 

`get_local_size(1)` = 32.

`get_local_id(1) + get_local_size(1) * get_local_id(0) = y + 32 * x`, обращение к памяти будет coalesced, так как здесь мы в каждой кэш линии будем изменять по одному значению. 32 * 32 = 1024 кэш линий записей произойдет в одной рабочей группе.

(c)

`1 + get_local_id(0) + get_local_size(0) * get_local_id(1) = 1 + x + 32 * y`, обращение к памяти все еще будет coalesced, но здесь в каждом warp-е будут изменения 2 кэш линий. 2 * 32 = 64 кэш линий записей произойдет в одной рабочей группе.