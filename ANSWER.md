# 1

`y1` будет проще и быстрее реализовать, тк вычисления двух элементов этого сигнала не зависят друг от друга. В случае же `y2` соседние элементы зависят друг от друга, поэтому их будет не распараллелить.

# 2

В одном варпе вычисляются WorkItem с различными x и с одинаковыми координатами y, z.

Тк `get_local_size(1) == 32`, то выражение `get_local_size(1) * get_local_id(0)` кратно 32.
Значит `idx % 32 == get_local_id(1) % 32`. Поэтому в рамках одного варпа это значение будет константным и `code divergence` не произойдёт.

# 3

## a 

Да, будет coalesced. 

`get_local_size(0) * get_local_id(1)` кратно 32, а внутри одного варпа обращение будет к одной линии кэша. Следовательно coalesced.

32 кэш линий записей произойдет в одной рабочей группе.

## b

В одном варпе `get_local_id(1)` не меняется и равно 32, а `get_local_size(0) * get_local_id(1)` кратно 32.
Не coalesced. Данные будут записываться не разные кэш линии. В каждом warp будет 32 кэш линий записи.

`32 * 32 = 1024` кэш линий записи произойдет в одной рабочей группе.

## c

Да, будет coalesced. Аналогично пункту а, но есть сдвиг на 1. Поэтому в каждом варпе будет 2 кэш линий записи.

`32 * 2 = 64` кэш линий записи произойдет в одной рабочей группе.