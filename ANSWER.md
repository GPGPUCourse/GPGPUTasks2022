# 1
`y1`, так как для его вычисления достаточно лишь входного сигнала, 
в то время как второй выходной сигнал зависит сам от себя, 
что заставит нас как-то упорядочивать его вычисление, 
и едва ли тут обойдётся без накладных расходов

# 2
Раз координата `x` меняется чаще всего, то рабочая группа 
будет обработана варпом по строкам, то есть в рамках одного варпа 
элементы будут различаться только по координате `x`.

`idx = get_local_id(1) + get_local_size(1) * get_local_id(0) = Const + 32 * get_local_id(0)`, 
а значит `idx % 32 = Const`, следовательно, в рамках одного варпа 
значение условия в блоке if будет одним и тем же, а code divergence не произойдёт

# 3
В задании 3.c важны конкретные условия, при которых обращения к памяти склеиваются.
Есть три варианта:
1. запрашиваемые элементы должны находиться друг от друга на расстоянии 128 или меньше, 
   то есть `data[127]` и `data[128]` -- склеятся
2. если поделить всю память `data` на блоки по 128 байт, запрашиваемые элементы 
   должны находиться в одном таком блоке
3. если поделить всю память видеокарты на блоки по 128 байт, запрашиваемые элементы
   должны находиться в одном таком блоке
   
Последние два варианта эквивалентны в нашем случае, так как `data` выравнено по 128 байтам,
и наверное это не просто так упомянулось в условии, так что буду считать верным третий вариант.
И всё же хочется спросить, а в каких источниках можно перепроверять себя по таким вопросам?

## 3.a
Так как рабочая группа будет обработана по строкам, сначала потоки варпа обратятся
к индексам `get_local_id(0) + get_local_size(0) * get_local_id(1) = get_local_id(0) + 32 * 0 = [0; 31]`,
потом `get_local_id(0) + 32 * 1 = [32; 63]`, и так далее, то есть
каждый раз записи будут происходить непрерывными кусками размера 32, 
начинающимися в индексах, кратных 32.

Если `1.0f` значит, что массив `data` имеет тип `float*` (что, впрочем, неоднозначно в данном случае),
значит эти куски будут выравнены по 128 байтам и всегда влезать в одну кэш линию,
следовательно обращение будет coalesced, а количество кэш линий записей будет равно количеству таких кусков,
то есть 32 (которые между собой не склеятся, так как будут выполнены варпом раздельно).

## 3.b

Снова посчитаю к каким индексам будут обращаться потоки варпа.
Сначала это будут `get_local_id(1) + get_local_size(1) * get_local_id(0) = 0 + 32 * get_local_id(0) = 0, 32, 64, ..., 992`,
потом `1 + 32 * get_local_id(0)`, то есть то же самое, но со смещением 1, ну и так далее.

А так как шаг в 32 элемента значит шаг в 128 байт (`float`, да?), значит в рамках
одного варпа никакие два элемента не попадут в один блок.
Следовательно, обращение не coalesced, никакие два запроса не склеятся, а значит их будет 1024.

## 3.c

Тут всё как в 3.a, но со сдвигом на 1 элемент, то есть на 4 байта. 
Следовательно, в нашем предположении об условиях склеивания обращений,
последний поток варпа всегда будет вылезать из блока по 128-байт.
Это обращение будет более coalesced чем в 3.b, то менее, чем в 3.a, 
а суммарно кэш линий записей будет 64.