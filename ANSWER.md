# Решение

### Задание 1

Поскольку `y2[n]` зависит от предыдущих `y2[n-2]` и `y2[n-1]`, то мы не сможем считать элементы `y2[i]` параллельно. 
Но в случае с `y1[n]` это возможно, поскольку оно не зависит от других элементов `y1[i]`.

### Задание 2

Code divergence не произойдет, поскольку заметим, что слагаемое `get_local_size(1) * get_local_id(0)` кратно 32, поскольку `get_local_size(1) = 32`.
Соответственно, выражение в `if` зависит только от `get_local_id(1)`, но это значение не будет меняться в рамках одного warp/wavefront, то есть будет одинаковое значение `idx % 32`.

### Задание 3

a) `get_local_size(0) * get_local_id(1)` кратно 32, так как `get_local_size(0) = 32`. 
`get_local_id(0)` будет принимать значения от 0 до 31 включительно в рамках одного warpa.
Соответственно, обращение к памяти будет coalesced, потому что будем обращаться к одной линии кеша в одном warpe.
В одной рабочей группе произойдет 32 кеш линий записей.

b) `get_local_size(1) * get_local_id(0)` кратно 32, так как `get_local_size(1) = 32`.
`get_local_id(1)` не меняется в рамках одного warpа.
Соответственно, обращение к памяти не будет coalesced, потому что в каждом warp будет происходить записать в 32 кеш линии. 
В одной рабочей группе будет происходить `32 * 32 = 1024` кеш линий записи.

c) `get_local_size(0) * get_local_id(1)` кратно 32, так как `get_local_size(0) = 32`.
`get_local_id(0)` будет принимать значения от 0 до 31 включительно в рамках одного warpa.
Этот пункт как пункт а), но есть сдвиг на 1, поэтому здесь в каждом warp будет происходить 2 кэш линий записи.
В одной рабочей группе произойдет `2 * 32 = 64` кеш линий записи.
