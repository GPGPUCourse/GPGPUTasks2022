## 1

Первое тривиально реализуется, почти как A+B. Второе сложнее и менее эффективно. Разница в том, что каждое y1[i] зависит от константного количества входных переменных, а во y2[i] &mdash; от i входных переменных.

## 2

`idx == get_local_id(1) + 32 * get_local_id(0)`

`idx % 32 == get_local_id(1)`

По условию внутри warp сначала меняется x. Так как размер warp'а равен `get_local_size(0)`, y и z будут одинаковы для всех потоков warp'а. То есть code divergence не произойдёт.

## 3

(a) Да, будет.

`32*32*sizeof(float)/128 = 32` кеш-линии.

(b) Нет, не будет.

В каждом варпе происходит запись в 32 кеш-линии. Итого, `32*32 = 1024` кеш-линии.

(c) Каждый warp будет писать в 2 кеш-линии (31 поток в одну и 1 в другую). Итого, `2*32 = 64` кеш-линии.

Считается ли это coalesced, я не понял.