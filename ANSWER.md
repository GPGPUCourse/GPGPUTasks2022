1) Сигнал `y1` проще, так как он зависит лишь от `x`, 
   а `y2` обязывает создать порядок вычислений, 
   так как построен на прошлых значениях его самого

2) Из условия понятно, что warp будет вычисляться с разными x
   и одинаковыми остальными осями, и что `get_local_size(0) = 32`.
   В таком случае condition для всех один, то есть нет code divergence
   
3)
   (а) Дополнительно к решению задачи 2 заметим, что `get_local_id(0) < 32`, 
       тогда обращаемся каждый раз к бачам памяти с размером 32, 
	   то есть обращаемся к одной кеш линии, то есть обращение к памяти coalesced и записей 32
	
   (b) Аналогично, но в этом пункте мы выйдем за пределы одного бача в 128 байт,
       то есть бращение к памяти не coalesced и записей 1024
	
   (с) Аналогично, но в этом пункте смещение на 1, то есть не coalesced и записей 64