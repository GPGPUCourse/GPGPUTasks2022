# Ответы
## Задание 1
Проще и быстрее реализовать y1, так как он не требует вычисления предыдущих элементов, за счет этого
элементы y1 будут считаться параллельно и зависимостей возникать не будет.

## Задание 2
Code Divergence не произойдет, так как 
* get_local_size(1) = 32 -> get_local_size(1) * get_local_id(0) % 32 == 0
* get_local_id(1) == const в одном warp
* if зависит только от get_local_id(1)
* idx % 32 в одном warp будет одинаково

## Задание 3
### (a)
* get_local_size(0) = 32 -> get_local_size(0) * get_local_id(1) % 32 == 0
* 0 <= get_local_id(0) <= 31 в одном warp
* Обращаемся к линии кэша в одном warp

Значит:
* Обращение к памяти coalesced
* В одной рабочей группе произойдет 32 кеш линий записей

### (b)
* get_local_size(1) = 32 -> get_local_size(1) * get_local_id(0) % 32 == 0
* get_local_id(1) == const в одном warp
* warp будет делать 32 кеш линий записи.

Значит:
* Обращение к памяти не coalesced
* В одной рабочей группе будет 32 * 32 = 1024 кеш линий записи.

### (c)
* get_local_size(0) = 32 -> get_local_size(0) * get_local_id(1) % 32 == 0
* 0 <= get_local_id(0) <= 31 в одном warp
* Изменения 2 кэш линий в каждом warp

Значит:
* Обращение к памяти будет coalesced
* В одной рабочей группе произойдет (2 * 32) кэш линий записей